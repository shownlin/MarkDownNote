# 計算機網路筆記

## OSI 七層
OSI是Open System Interconnect的縮寫，意為開放式系統互聯。
![](https://i.imgur.com/e3qheg4.png)

傳統IP網路有一個很重要的階層機制，就是OSI的網路七層架構，這七層分別是：

* Layer 1 實體層 (Physical Layer)：這一層定義到了網路實體線路，包括網路線的規格結構，以及設備之間的實體溝通方法，例如網路卡要怎麼傳送封包，無線網路要怎麼傳遞無線訊號

* Layer 2 資料連結層 (Data-Link Layer)：這一層開始將實體的概念虛擬化，定義好軟體怎麼指定要與誰溝通，在這一層，溝通用的是MAC Address，這個地址是LAN網路中唯一的代碼，可以很明確地指定封包要傳遞的目的地

* Layer 3 網路層 (Network Layer)：這一層開始定義網路網路(WAN)的溝通機制，每個設備都會有一個為一的IP地址，但因為IPv4定義的IP數量不夠多，所以開始有一些NAT技術產生，讓多個設備共用IP地址，這個問題在IPv6有進一步的解決

* Layer 4 傳輸層 (Transport Layer)：傳輸層在網路層之上加上一些保證可用性、循序性與可靠性等等特性，讓資料的傳輸可以透過這一層的控制更加穩定，一般最常用到的就是TCP和UDP這兩個協定

* Layer 5 會議層(Session Layer)：會議層主要是用來做Session管理，Session代表至少一來一回的溝通，可能用來做認證或者會議的建立等等

* Layer 6 展現層 (Presentation Layer)：一般比較常用在這一層的技術就是加密與解密

* Layer 7 應用層 (Application Layer)：所有網路的應用服務，例如網頁服務、郵件服務等等，你所有看得到的網路服務幾乎都是在這一層

## OSI 五層

| 層數 | 名稱              | 關鍵字    |
|:----:| ----------------- | --------- |
|  5   | Application Layer | 應用程式  |
|  4   | Transport Layer   | TCP / UDP |
|  3   | Network Layer     | IP        |
|  2   | Data Link Layer   | MAC       |
|  1   | Physical Layer    | 網路線    |

在每一層中，都定義了非常多的協定(protocol)。

![](https://i.imgur.com/0t7CnWz.png)

Application Layer：
Host A 跟 Host B 的 Web Sever 作資料傳輸，跟程式員最靠近，提供為應用軟體而設計的介面，以設定與另一應用軟體之間的通訊。例如：HTTP、HTTPS、FTP、Telnet、SSH、SMTP、POP3等。

Transport Layer：
例如兩個遠端主機建立了一個連接。

Network Layer：
通過IP地址傳送封包(Data packe)。

Data Link Layer：
通過MAC地址，交換幀數據Data Frame。

Physical Layer：
網路線、網卡。

[參考資料1](https://microchipdeveloper.com/com4102:five-layer-software-model-overview)、[參考資料2](https://www.youtube.com/watch?v=iNITVjVLpxI)

![](https://i.imgur.com/1wqE197.png)

為了從 TCP/IP 網路傳送和接收資料，資料會在每一層中間傳輸，發送訊息時，資料不斷往下一層傳輸。
例如上圖，從應用層出發，每往下一層就把該層的訊息加入到封包之中，直到形成格式完整的封包。
每一層增加的訊息就叫做header，每一層增加的header中包含了該層工作所需要的資訊。

## 實體層

即物理層，光纖、電纜、無線電波之類，把電腦連接起來的物理手段，規定了一些電器的特性，負責傳送 0/1 這樣的電信訊號。
但單純地傳輸 0/1 是沒什麼意義的，所以又有了下面的一層，資料連結層。

## 資料傳輸層

乙太網路(ethernet)是一種協定，一組電信訊號叫作一個frame。

其資料結構如下圖：
![](https://i.imgur.com/AKzGqKX.png)

其中Header中包含了發送者是誰、接收者是誰、資料類型是什麼等等的說明項，
而Data中則是要交換數據的具體內容。

整個幀的資料內容最短為46 Bytes，最長為1500 Bytes，但有時候資料內容龐大，就需要切割成多個幀。

這一層最主要的就是MAC地址，發送者和接收者的設備都具有世界上獨一無二的MAC地址用來辨識身分，長度為48 bits，通常我們用12個十六進制數去表示。

如：
![](https://i.imgur.com/EXTULd9.png)

前六個十六進制數為廠商的編號，後六個則為廠商的流水編號。

有了這個MAC地址就可以在同一個子網路中透過ARP協定來定位網卡和封包的路徑。

ARP的運作方式透過廣播來進行：
![](https://i.imgur.com/UkIbv1j.png)

乙太網路中並不是精準的將封包傳送到接收方，而是放到同個子網路上進行廣播，所以子網路中每一台電腦都可以接收到這個封包，讓每一台電腦自己去判斷自己不是接收者。

它們都過frame中的header，找到了接收方的MAC地址，然後與自身的MAC地址對比，如果相符就接收它，如果不是就丟棄。

所以網際網路上其實是由無數個子網路所組成，子網路中的傳輸透過ARP protocol，若傳送與接收方不在同一個子網路，則是由路由(Router)的方式來發送。

而要怎麼區分傳送與接收方在不在同一個子網路呢？
我們知道MAC地址只與廠商和它的流水號有關，所以在資料傳輸層是辦不到這件事情的，這也導致了接下來網絡層的誕生。

## 網路層

網路層的作用是引進一套新的地址，讓電腦可以區分傳送和接收方在不在同一個子網路中。
這一套地址就是網路地址，簡稱網址。

它可以決定數據的路徑選擇和轉寄，將網路表頭（NH）加至數據包，以形成封包。網路表頭包含了網路資料。例如:網際網路協定（IP）等。

所以MAC地址和網路地址之間是沒有任何聯繫的，MAC地址是綁定在網卡上，網路地址是由管理員分配的。

用途差異：


| IP address               | MAC Address                           |
| ------------------------ | ------------------------------------- |
| 區分電腦在哪一個子網路。 | 將資料發送到子網路中特定的MAC地址上。 |

所以邏輯上可以知道，這兩者間的處理順序必定是：
1. 先處理網路位址
2. 再處理MAC地址

因此又引出了一個協定，IP協定，廣泛採用的為IPv4，由32個bits組成，如192.168.1.3。
在網際網路上，每一個電腦都會分配到一個IP地址，它的範圍由0.0.0.0 ~ 255.255.255.255，
這個IP地址可以拆成兩部分，前面的部分代表網路，後面的部分代表主機，如：

![](https://i.imgur.com/0lNViZg.png)

圖片中192.168.1.20，前面192.168是網路部分，後面1.20代表主機。
若兩個地址在同一個子網路，那兩者的ip的網路部分肯定是相同的，但是我們要怎麼判斷呢？

利用一個32位元的mask(子網路遮罩)與IP位址作AND運算，我們就可以取出網路的部分，
而後面剩餘的部分就是host部分。

IP協定的總結：
1. 為每一台電腦分配一個IP地址。
2. 確定那些地址在同一個子網路內。

IP封包：
![](https://i.imgur.com/b5jtRdV.png)

由上圖所述，其實我們是將上層的封包直接放進下層封包的資料部分，這就是OSI分層結構的好處之一，上層的變動完全不會涉及到下層的變動。與程式設計的結構很像，將參數用物件封裝起來，下一層就不用再添加參數，在物件中添加屬性即可。

IP封包的Header主要包含版本號碼、長度、IP地址等等訊息，長度約為20 Bytes，Data部分依然是舉體要交換的訊息內容，若IP封包超過1500個Byte，那就要分割成多次發送。

在網路層中，必須同時知道對方的MAC地址和IP地址，通常情況下我們只知道對方的IP地址，所以這裡還是涉及到ARP的協定。

![](https://i.imgur.com/oTRByz7.png)

若知道對方的IP地址，相當於我們知道對方的子網路，所以這時可以發送一個封包含有到連接兩個子網路的Gateway，該封包中包含要查詢主機的IP地址，而對方的MAC地址臨時用一組6個16進制數去代替，而對方所在的子網路每一台電腦都會收到這個封包，當這些主機收到這些封包後就會把裡面的IP地址取出來，和自己的IP地址比對，如果相符就回覆對方「我就是你要找的那台主機！」並且附上自己的MAC地址，接下還雙方就可以建立通訊。

當我們有了IP地址和MAC地址，那我們就可以在兩台主機之間建立連線，然而一台電腦可能同時有好幾個應用程式需要建立連線，我們要如何區分這個連線是要給瀏覽網頁，或是給某個應用程式傳送訊息呢？

也就是說，我們還需要一個參數，來分別這個packet是給哪個process所使用的。

### 端口(Port)

端口其實是每一個使用網卡的程式分配到的編號，每一個packet都會發送到一台主機上的特定端口上，所以不同的程序就會取到自己所需要的數據，而Port編號在0 ~ 65535的範圍中，其中0 ~ 1023是由系統所佔用，這也就是為什麼我們有時在本地端去啟用80或443(HTTP/HTTPs)會失敗的原因(只能在kernel mode下啟用)。

## 傳輸層

Transport Layer是用來建立端口到端口之間的聯繫，相比之下，網路層則是建立主機到主機之間的連線，只要確定了主機和端口，我們就能使process之間作交流，所以UNIX系統把主機+端口叫做網路插座(Socket)。

『Socket 就是一個網路上的通訊端點，使用者或應用程式只要連接到 Socket 便可以和網路上任何一個通訊端點連線，Socket 之間通訊就如同作業系統內程序（Process）之間通訊一樣。』

傳輸層有兩個重要的協定：
1. UDP協定
2. TCP協定

UDP 是由header + data組成，其中header部分包含了send port和receive port，這個程式是由哪個端口發出的，要由誰去接收，都在header中定義，而data部分就是要傳輸資料的具體內容，並把整個UDP封包放入整個IP封包的data部分之中。

UDP的header只有8 Bytes，這種協定簡單、容易實現、速度快，缺點是可靠性差，發出封包後不知道對方是不是已經接收到了。

為了解決這個問題，TCP被提出。

TCP比較複雜，基本上可以看成有確認機制的UDP協定，每發出一個packet都要進行確認是否有遺失，這樣發送方就知道需不需要重新發送packet，採用三次握手機制，如圖：

![](https://i.imgur.com/hXJvG9W.png)

TCP可以保證資料不會丟失，缺點是過程複雜、實現困難，TCP的封包和UDP的封包一樣都是嵌在IP封包的Data部分，TCP封包沒有長度的限制，理論上可以無限長，但通常不會超過IP封包的data部分來避免拆成多個封包。

兩者之比較：

| TCP                                      | UDP                        |
| ---------------------------------------- | -------------------------- |
| 面向連接（有點像打電話）                 | 無連接                     |
| 提供可靠服務（校驗、重傳、順序控制等等） | 不保證可靠                 |
| 點對點                                   | 實時性強(Real time)        |
| 資源消耗高                               | 一對一、多對一、多對多皆可 |
|                                          | 資源消耗較少               |

## 應用層

作用是在規定應用程式的資料格式，例如：

TCP協定可以為各式各樣的應用程式傳送數據，比如說Email、www、FTP等等，然而必須要有規範來規定這些應用程式的資料格式，而這些規範、協定就構成了整個應用層部分。

![](https://i.imgur.com/CxPufaM.png)

如果兩台電腦不在同一個子網路，就無法知道接收方的MAC地址，需透過Gateway來轉送資料，
![](https://i.imgur.com/3b948q8.png)

![](https://i.imgur.com/d1e0Xzt.png)

所以若要透過Gateway轉送資料，則需要跟自己同一個Gateway的MAC address，
因此分為兩種場景：

| 場景           | 封包地址                       |
| -------------- | ------------------------------ |
| 同一個子網路   | 對方的MAC地址，對方的IP地址    |
| 非同一個子網路 | Gateway的MAC地址，對方的IP地址 |

### 動態IP地址

利用DHCP協定，當電腦開機時，會自動分配到一個IP地址。

在DCHP協定中，規定了在每一個子網路中，會有一台專門負責分配此網路內的所有IP位址的電腦，叫做DHCP伺服器。

所有新的電腦加入這個網路之後，必須送出DHCP請求封包，去申請IP地址。

DHCP是應用層的協定，它的申請封包長這樣：

![](https://i.imgur.com/ZqI9bBI.png)

其中，
乙太網路標頭接收方填入：```FF:FF:FF:FF:FF:FF```
IP標頭則是發送與接收方都未知，因此發出方填入：```0.0.0.0```，而接收方填入：```255.255.255.255```
UDP則是在發出方端口設為68，接收方為67。

當構成上述封包，就可以廣播到子網路中，當DHCP伺服器收到這個封包後，就會為申請的電腦分配一個IP位址，並發回去一個DHCP響應(response)封包。

### DNS協定

發送封包需要對方的IP地址，但如果我們只知道對方的www網址，DNS能幫助我們將www網址轉換為IP地址，其封包如下：

![](https://i.imgur.com/1eXMv5a.png)

DNS接收到這個封包就會作出響應，告訴發出方所查詢的ip地址。

### HTTP協定

通常走80 port。

![](https://i.imgur.com/IceXlgP.png)

用明文方式傳輸資料，沒有任何的加密，例如訪問一個網站需要輸入密碼，那我們的帳號密碼就會透過各種路徑轉發到網站的伺服器上面，但要是有人中途攔截，那它就會直接知道我們的所有訊息。

### HTTPS協定

[參考資料](https://tw.alphacamp.co/blog/http-https-difference)

建立一個安全的連接通道，伺服器會發送一份由第三方CA(Certificate Authority)頒發的網站證書訊息到要求建立連結的client端，客戶端可以透過作業系統內預先安裝的憑證機構來驗證這個網站是否安全，其中CA是建立KPI的基石（公開金鑰基礎建設）。

HTTPS的主要作用是在不安全的網路上建立一個安全通道，並可在使用適當的加密套件和伺服器憑證可被驗證且可被信任時，對竊聽和中間人攻擊提供合理的防護。

CA也擁有用戶的憑證（內含公鑰）和私鑰。網上的公眾用戶通過驗證CA的簽名從而信任CA，任何人都可以得到CA的憑證（含公鑰），用以驗證CA所簽發的憑證。

## 防止中間人攻擊

公開金鑰加密，也有人之稱為「非對稱式加密」；

在這個加密規則中，每個通訊者都會有成對的兩把鑰匙：

一把「公鑰」，一把「私鑰」。
顧名思義，公鑰是所有人都看得到的，而私鑰是只有通訊者自己才看得到的；

每個資料被任意一把鑰匙加密後，必須要透過與之配對的另一把鑰匙才能解密；
例如我用我的私鑰加密的密文，就只能被我的公鑰解密，反之亦同。

在這樣的規則下，進行通訊會發生什麼事呢？
假想一下：Alice 和 Bob 準備進行通訊，而 Eve 是不懷好意的竊聽者；
Alice 把要傳遞的明文經過 Bob 的公鑰進行加密後，再進行傳遞，由於 Bob 的私鑰只有 Bob 擁有，
即使 Eve 竊取到了密文，也無法將其解密回明文。

這樣子是不是就可以安心進行通訊了呢？
很遺憾的，還是沒辦法；因為通訊的雙方，雖然看得到對方的公鑰，
但沒辦法證明這個公鑰是通訊的對方所擁有。

我們設想另一個情況：
Alice 和 Bob 準備進行通訊，而 Eve 是不懷好意的竊聽者，且 Alice 和 Bob 都把 Eve 當成是通訊的對方；這樣的情境下，Alice 把明文用 Eve 的公鑰加密後，將密文傳遞出來，隨即被 Eve 攔截、解密後，再用 Bob 的公鑰重新加密明文，再傳遞給 Bob，反之亦同，這樣子 Alice 和 Bob 都不會知道有 Eve 的存在，但 Eve 卻成功的取得了通訊內容；這就叫做[中間人攻擊](https://zh.wikipedia.org/zh-tw/中间人攻击)。

![](https://i.imgur.com/t5zZgHJ.png)

所以我們需要憑證來證明此公鑰確實是屬於 Sever 的，而證明的方法就是「數位簽章」。

有個簡單的概念:
```
憑證 = 公鑰 + 此公鑰是屬於哪個Server的資訊 + 數位簽章
```

概念就是請一個有公信力的憑證頒發機構為公鑰的副本背書，SSL 憑證包含下列資訊：

* 憑證擁有者的名稱
* 憑證的序號及到期日期
* 憑證擁有者公開金鑰的副本
* 憑證簽發有關單位的電子簽名
* 由憑證頒發機構簽發的憑證有免費的，也有每年收費數美元到數千美元不等的。

當通訊開始時，Alice 會先傳遞數位憑證給 Bob，而 Bob 便可以透過數位簽章，來證明憑證的內容確實是屬於 Alice 的；

如此一來，證明公鑰是屬於誰的問題就被解決了，即使竊聽者想要從中竊聽，也因為憑證頒發機構的數位簽章，竊聽者將無從介入通訊過程。

參考資料：[這裡](https://medium.com/髒桶子/week10-https的s到底怎麼運作的-為什麼非對稱金鑰需要數位簽章來組成憑證呢-資安介紹篇-f126ba5c1c38)
